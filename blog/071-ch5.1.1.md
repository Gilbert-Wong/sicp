SICP 読書ノート#71 - 5.1 レジスタ計算機の設計 (pp.293-306)
======================================

色々と忙しくて、長らくサボってましたが、約半年ぶりに再開します。

Schemeを忘れていないかと心配でしたが、4章までの苦労が染み付いてたせいか、そうでもなかった。よかった！


5章を学ぶ意味
--------------------------------
5章の冒頭にまとめてあります。

- 4章ではLispの言語解釈について学ぶことができたが、Lisp制御システムのメカニズムまでは答えられていない
    + 例えば、部分式の評価や反復/再帰プロセスの生成の実現方法など
    + これは4章のLisp処理系がLispシステムの上に成り立っているから
- 5章ではこの残された謎を解くためレジスタマシンを実装しながら以下を学んでいく
    + §5.1では、レジスタマシンの命令列や設計について
    + §5.2では、レジスタマシンを動作させるシミュレータについて
    + §5.3では、consのメモリ演算やその割り当てについて
	+ §5.4では、プリミティブな手続き(おそらくspecial form)をレジスタマシンに定式化する手法について
	+ §5.5では、Schemeプログラムをレジスタマシンで実行可能な命令列に翻訳するコンパイラについて


### 問題 5.1
テキストのgcdの例を参考に見よう見まねでやってみる。

factorialのデータパス図。

![image](https://farm2.staticflickr.com/1623/25385395922_9c8ded7d28_o_d.png)

factorialの制御図。

![image](https://farm2.staticflickr.com/1486/25477758306_220f416ebd_o_d.png)


### 問題 5.2

```scheme
(controller
 (assign product (const 1))
 (assign counter (const 1))
 test-counter
   (test (op >) (reg counter) (reg n))
   (branch (label factorial-done))
   (assign product (op *) (reg product) (reg counter))
   (assign counter (op +) (reg counter) (const 1))
   (goto (label test-counter))
 factorial-done)
```

### 問題 5.3

```scheme
(controller
 (assign x (op read))
 (assign guess (const 1.0))
 test-good-enough?
   (test (op good-enough?) (reg guess) (reg x))
   (branch (label sqrt-done))
   (assign guess (op remove) (reg guess) (reg x))
   (goto (label test-good-enough?))
 sqrt-done)
```

```scheme
(controller
   (assign continue (label fact-done))     ; set up final return address
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ;; Set up for the recursive call by saving n and continue.
   ;; Set up continue so that the computation will continue
   ;; at after-fact when the subroutine returns.
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   ; val now contains n(n-1)!
   (goto (reg continue))                   ; return to caller
 base-case
   (assign val (const 1))                  ; base case: 1!=1
   (goto (reg continue))                   ; return to caller
 fact-done)

```

| step | instruction | n | val | continue | stack |
|------|-------------|---|-----|----------|-------|
| 1  | `(assign continue)` | `3` | | `(label fact-done)` | |
|    | fact-loop 1回目 |
| 2  | `(test (op =) (reg n) (const 1))` | `3` | | `(label fact-done)` | |
| 3  | `(save continue)` | `3` | | `(label fact-done)` | `(label fact-done)` |
| 4  | `(save n)` | `3` | | `(label fact-done)` | `3`,`(label fact-done)` |
| 5  | `(assign n (op -) (reg n) (const 1))` | `2` | | `(label fact-done)` | `3`,`(label fact-done)` |
| 6  | `(assign continue (label after-fact))` | `2` | | `(label after-fact)` | `3`,`(label fact-done)` |
| 7  | `(goto (label fact-loop))` | `2` | | `(label after-fact)` | `3`,`(label fact-done)` |
|    | fact-loop 2回目 |
| 8  | `(test (op =) (reg n) (const 1))` | `2` | | `(label after-fact)` | `3`,`(label fact-done)` |
| 9  | `(save continue)` | `2` | | `(label after-fact)` | `(label after-fact)`,`3`,`(label fact-done)` |
| 10 | `(save n)` | `2` | | `(label after-fact)` | `2`,`(label after-fact)`,`3`,`(label fact-done)` |
| 11 | `(assign n (op -) (reg n) (const 1))` | `1` | | `(label after-fact)` | `2`,`(label after-fact)`,`3`,`(label fact-done)` |
| 12 | `(assign continue (label after-fact))` | `1` | | `(label after-fact)` | `2`,`(label after-fact)`,`3`,`(label fact-done)` |


--------------------------------

※「SICP読書ノート」の目次は[こちら](/entry/sicp/index)


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />


